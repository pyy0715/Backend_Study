# Chapter 4, HTTP의 구조 및 핵심 요소

Created: July 8, 2021

# HTTP

HTTP는 웹 상에서 서로 다른 서버간에 하이퍼텍스트 문서, HTML을 주고 받을 수 있도록 만들어진 프로토콜, 통신 규약이다.

## HTTP 통신 방식

통신 방식에는 2가지 특징이 있음. 하나는 HTTP의 요청과 응답 방식이고, 또 다른 특징은 stateless다.

1. request와 response 방식
    
    http를 기반으로 통신할 떄 클라이언트가 서버에게 http요청을 보내면 서버는 요청을 처리한 후 결과에 따른 응답을 클라이언트에게 보냄으로써 http통신이 이뤄지게 됨.
    
2. stateless
    
    클라이언트와 서버는 http통신을 여러 번 주고받는 것이 일반적이지만 이러한 통신들은 동일한 클라리언트나 서버라도 서로 연결되있지 않음. **즉 각각의 http통신은 독립적이며 상태라는 개념이 존재하지 않음.**
    
    로그인과 같이 이전 통신의 정보가 필요한 경우 쿠키나 세션들을 사용하여 데이터를 저장하여 http요청을 처리함.
    

<aside>
💡 **쿠키와 세션의 차이점**
쿠키와 세션 모두 http통신상에서 필요한 데이터를 저장하는 메커니즘이다. 쿠키는 웹 브라우저, 즉 클라이언트 측에서 데이터를 저장하는 반면에 세션은 웹 서버에서 데이터를 저장한다.

</aside>

## HTTP 요청 구조

HTTP 요청 메세지는 크게 다음의 세 부분으로 구성되어 있다.

1. Start Line
    
    ```python
    (ex): GET /search HTTP/1.1
    start line은 세 부분으로 구성되어 있음.
    1. HTTP Method: HTTP 요청이 의도하는 액션을 정의하는 부분.
    2. Request Target: 해당 HTTP 요청이 전송되는 목표 주소
    3. HTTP version: 버전을 명시하는 이유는 HTTP버전에 따라 요청 메세지의 구조나 데이터가 
    약간씩 다를 수 있기 떄문에 서버가 받은 요청의 HTTP version에 따라서 응답하기 위함이다.
    ```
    
2. Headers
    
    ```python
    헤더 정보는 HTTP 요청 그 자체에 대한 정보를 담고 있음. 
    헤더는 파이썬의 딕셔너리처럼 key와 value로 구성되어있음.
    자주 사용되는 헤더 정보는 다음과 같음.
    - HOST(호스트의 URL주소)
    - User-Agent(요청을 보내는 클라이언트의 정보)
    - Accept(해당 요청이 받을 수 있는 응답 body 데이터 타입을 알려주는 헤더)
    - Connection(해당 요청이 끝난 후에 클라이언트와 서버가 계속해서 네트워크 연결할지를 나타내는 헤더)
    - Connect-Type(HTTP 요청이 보내는 메세지 body의 타입을 알려주는 헤더)
    ```
    
3. Body
    
    HTTP 요청이 전송하는 데이터를 담고 있는 부분이다. 전송하는 데이터가 없다면 body 부분은 비어있게 된다.
    

## HTTP 응답 구조

응답 메세지의 구조도 요청 메세지와 마찬가지로 크게 세 부분으로 구성되어 있다. 

## 자주 사용되는 HTTP 메소드

- GET
    
    어떠한 데이터를 서버로부터 요청할 때 주로 사용되는 메소드. 즉 데이터의 생성이나 수정 그리고 삭제등의 변경 사항 없이 단순히 데이터를 받아 오는 요청
    
- POST
    
    GET과 다르게 데이터를 생성하거나 수정 및 삭제 요청을 할 떄 사용되는 메소드
    
    PUT(생성), DELETE(삭제) 메소드들이 있지만 POST로 통일해서 사용함.
    
- OPTIONS
    
    특정 엔드포인트에서 허용하는 메소드들이 무엇이 있는지 알고자 하는 요청에서 사용되는 메소드.
    
    엔드포인트는 허용하는 메소드가 지정되도록 되어 있으며, 허용하지 않는 메소드의 요청이 들어올시 `405 Method Not Allowed` 응답을 보내게 된다.
    

## 자주 사용되는 HTTP Status Code와 Text

메소드를 잘 이해하는 만큼 status code와 text를 잘 이해하여 적절한 응답을 보내는 것 또한 중요하다.

- `200 OK` , HTTP요청이 성공적으로 처리되었을 떄 보내는 status code
- `301 Moved Permanently` , HTTP 요청을 보낸 엔드포인트의 URL주소가 바뀌었다는 것을 나타냄, 이 떄 새로운 주소가 Location 헤더에 포함되어 나타남.
- `400 Bad Request`, 잘못된 요청일 떄 보내는 응답 코드
- `401 Unauthorized`, 해당 요청을 보내는 주체의 신분 확인이 요구되거나 확인할 수 없을떄 보내는 응답 코드
- `403 Forbidden`, 요청을 보내는 주체가 해당요청에 대한 권한이 없음을 나타내는 응답 코드
- `404 Not Found`, 요청을 보내고자 하는 URI가 존재하지 않을 때 보내는 응답 코드
- `500 Internal Server Error`, 내부 서버 오류가 발생했다는 것을 알려주는 응답 코드

## API 엔드포인트 아키텍처 패턴

API의 엔드포인트 구조를 구현하는 방식에는 크게 2가지가 있는데 하나는 REST 방식이고 다른 하나는 GraphQL이다.

### RESTful HTTP API

RESTful API는 API에서 전송하는 리소스를 URI로 표현하고 해당 리소스에 행하고자 하는 의도를 HTTP 메소드로 정의하는 방식.

각 엔드포인트는 처리하는 리소스를 표현하는 고유의 URI주소를 가지고 있으며, 해당 리소스에 행할 수 있는 행위를 표현하는 HTTP메소드를 처리할 수 있게 된다.

이를 통한 장점은 자기설명력, 즉 엔드포인트의 구조만 보더라도 해당 엔드포인트가 제공하는 리소스와 기능을 파악할 수 있음.

### GraphQL

기존 REST API방식의 문제점은 API의 구조가 특정 클라이언트에 맞추어져서 다른 클라이언트에 사용하기에 적합하지 않음. 즉 모바일과 데스크탑 앱 개발에 있어서 구현해놓은 틀에 맞추어 사용하여야 하다 보니 그 틀에서 벗어나는 사용이 어려워져 자유도가 떨어짐.

GraphQL은 REST방식의 API과는 다르게 엔드포인트가 오직 하나다. 그리고 엔드포인트에 클라이언트가 필요한 것을 정의해서 요청하는 식이다.  즉 서버가 정의한 틀에서 클라이언트가 요청하는 것이 아니라 클라이언트가 필요한 것을 서버에 요청하는 방식

### 차이점

```
# REST 방식의 API
GET /users/1
GET /users/1/friends

# 한 줄로 작성
GET /users/1?include=friends.name 

-> 둘 다 비효율적이고 복잡함. 사용자 정보들 중 다 필요하지 않을 수도 있고, 
이름만 필요하거나 혹은 이메일도 필요하게 된다면 HTTP 요청이 더 복잡해짐

# GraphQL
POST /graphql
{
	user(id: 1){
		name
		age
		friends {
			name
		}
	}
}
```