# Chapter7, 인증

Created: August 14, 2021

수많은 API에서 인증은 공통적으로 구현되는 엔드포인트들 중 하나이다.

private API는 사용자 혹은 클라이언트를 제한하기 위해, public API는 사용 횟수 제한, 남용 방지 그리고 사용자 통계등의 이유로 엔드포인트를 필요로 한다.

## 인증

인증은 사용자의 신원을 확인하는 절차이다. 일반적으로 웹사이트에서 사용자가 로그인을 하여 아이디와 비번을 확인하는 절차를 이야기한다. 즉 로그인 기능을 구현하는 것이 인증 엔드포인트이다.

시스템적으로 로그인 기능은 다음과 같은 절차를 통해 구현될 수 있다.

```python
1. 사용자가 가입 절차를 통해서 사용자의 아이디와 비밀번호를 생성
2. 사용자의 아이디와 비밀번호를 데이터베이스에 저장. 이떄 사용자의 비밀번호는 암호화해서 저장한다.
3. 사용자가 로그인할 떄, 아이디와 비밀번호를 입력한다.
4. 사용자가 입력한 비밀번호를 암호화한 후, 그 값을 이미 암호화되어서 DB에 저장된 비밀번호와 비교
5. 비밀번호가 일치하면 로그인 성공!
6. 로그인에 성공하면 백엔드 API서버는 access token을 프론트엔드 혹은 클라이언트에게 전송
7. 로그인 성공 후, 다음부터는 해당 사용자의 access token을 첨부해서 request에 서버에 전송함으로써 매번 로그인하지 않아도 되도록 한다.
```

## 사용자 비밀번호 암호화

사용자의 비밀번호를 데이터베이스에 저장할 떄 암호화해서 저장해야 하는 이유는 아래와 같다.

1. 외부의 해킹 공격에 의해 데이터베이스가 노출되었을 경우에 대비
2. 내부 인력에 의해 데이터베이스가  노출되었을 경우에 대비

이러한 노출이 위험한 경우는 많은 사람들이 비밀번호를 각 사이트 혹은 서비스마다 다르게 설정하지 않고 동일하게 설정하기 때문임.

## One-Way Hash Function

사용자의 비밀번호를 암호화할 떄는 단방향 해시함수(one-way hash function)이 일반적으로 쓰인다. 단방향해시 함수는 복호화를 할 수 없는 암호화 알고리즘이다. 즉 사용자의 비밀번호를 데이터베이스에 저장할 때는 복호화 할 목적으로 사용하지 않고, 온전히 본래의 비밀번호를 값을 알지 못하도록 방지하는데에 목적이 있다.

원본 메세지를 알면 암호화된 메세지를 구하기는 쉽지만, 암호화된 메세지로는 원본 메세지를 구할 수 없다.

원래의 비밀번호와 굉장히 유사한 비밀번호라도 암호화된 해시 함수 값은 완전히 다르게 되는데 이를 애벌런시 효과라고 한다. 원본값과 해시값 사이에 직접적인 연관성이나 패턴이 없도록 하여 원본 값을 추론하는 것을 어렵게 만들도록 한다.

## bcrypt 암호 알고리즘

위에서의 단방향 해시 암호 알고리즘은 복호화를 할 수 없어 원본 값을 절대로 복구할 수 없을 것으로 생각되지만 취약점이 분명히 존재하고 해킹도 가능하다.

### rainbow attack

rainbow attack은 미리 해시값들을 계산해 놓은 테이블인 rainbow table이라는 테이블을 먼저 생성해 놓은 후 해시 함수 값을 역추적해서 본래 값을 찾아내는 해킹방법.

즉 해시 값을 복호화하는 것이 아니라 사전에 가능한 영문,숫자,기호 조합들로 구성된 다양한 스트링값들을 연산한 후, 그 값들을 미리 해시 암호화해놓은 후 해시 값끼리 매칭하는 방식으로 본래 암호 값을 찾는 방식.

이는 해시 함수의 실행 속도가 굉장히 빠르므로 조합들의 양이 방대해도 충분히 구현이 가능하다.

이러한 단방향 해시 함수의 취약점들을 보완하기 위해 일반적으로 2가지의 보완점이 사용됨.

- salting
    
    요리에 간을 위해 소금을 뿌리듯이, 실제 비밀번호 이외에 추가적으로 랜덤한 데이터를 더하여서 해시 값을 계산하는 방법.
    
- 키 스트레칭
    
    기존 단방향 해시 알고리즘들의 실행 속도가 너무 빠르다는 취약점을 보완하기 위해서 단방향 해시함수 값을 계산한 후 그 해시 값을 또 해시하고, 이를 여러 번 반복하는 방법.
    

**salting과 키 스트레칭을 구현한 해시 함수 중 가장 널리 사용되는 것이 bcrypt이다.**

## access token

2장에서 설명되어있듯이, HTTP는 stateless이다. 각각의 HTTP 통신은 독립적이며 이전에 어떠한 HTTP 통신들이 실행되었는지 알지 못한다. 이러한 HTTP의 성질 때문에 생기는 이슈 중 하나가 바로 인증 절차이다.

HTTP 요청을 처리하기 위해서 필요한 모든 데이터를 첨부하여 요청을 보내야 하는데 로그인 정보 또한 첨부해서 보내야 API 서버에서 해당 사용자가 로그인된 상태라는 것을 알 수 있다. access token이 바로 로그인 정보를 담고 있으며, 이를 통해 API서버에서 로그인 여부를 확인할 수 있다.

## JWT

access token을 생성하는 방법 중 가장 널리 사용되는 기술은 JWT(Json to Web Token)이다. 이름 그대로 JSON데이터를 token으로 변환하는 방식이다. 

JWT에는 단순 데이터 전송 기능 이외에 검증의 기능도 가지고 있다.

### JWT 구조

JWT는 다음 세 부분으로 구성되어 있다.

- header
    
    헤더는 두 부분으로 되어 있으며, 토큰 타입 그리고 사용되는 해시 알고리즘을 지정한다.
    
    ```json
    # 헤더를 Base64URL 방식으로 코드화
    {
    	"alg": "HS256",
    	"typ": "JWT"
    }
    ```
    
- payload
    
    payload는 JWT를 통해 실제로 서버 간에 전송하고자 하는 데이터 부분.
    
    ```json
    {
    	"user_id": "2",
    	"exp": "1539517391"
    }
    ```
    
- signature
    
    signature는 Base64URL 코드화된 header와 payload, 그리고 JWT secret을 헤더에 지정된 암호 알고리즘으로 암호화하여 전송한다. 프론트엔드가 JWT를 백엔드 API 서버로 전송하면 서버에서는 전송받은 JWT의 signature 부분을 복호화하여 서버에서 생성한 JWT가 맞는지 확인한다.